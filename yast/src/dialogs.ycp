/**
 * File:	include/smt/dialogs.ycp
 * Package:	Configuration of smt
 * Summary:	Dialogs definitions
 * Authors:	Lukas Ocilka <locilka@suse.cz>
 *
 * $Id: dialogs.ycp 27914 2006-02-13 14:32:08Z locilka $
 */

{
    textdomain "smt";

    include "smt/helps.ycp";
    include "smt/complex.ycp";

    import "Wizard";
    import "Popup";
    import "SMTData";
    import "Label";
    import "Confirm";
    import "Progress";
    import "Message";
    import "PackageSystem";
    import "Label";
    import "RunlevelEd";
    import "SuSEFirewall";
    import "FileUtils";
    import "GPG";
    import "Hostname";

    integer sl = 100;

    boolean text_mode = UI::TextMode();

    map <string, string> smt_cron_scripts = $[
	"/usr/lib/SMT/bin/smt-repeated-register"	: _("NCC Registration"),
	"/usr/lib/SMT/bin/smt-daily"			: _("Synchronization of Updates"),
	"/usr/lib/SMT/bin/smt-gen-report"		: _("Generation of Reports"),
	"/usr/lib/SMT/bin/smt-run-jobqueue-cleanup"	: _("Job Queue Cleanup"),
    ];

    string status_icons_dir = "/usr/share/icons/hicolor/16x16/status";

    map <string, string> smt_status_icons = $[
	// clients
	"critical"		: sformat ("%1/client-%2.xpm", status_icons_dir, "critical"),
	"unknown"		: sformat ("%1/client-%2.xpm", status_icons_dir, "unknown"),
	"updates-available"	: sformat ("%1/client-%2.xpm", status_icons_dir, "updates-available"),
	"up-to-date"		: sformat ("%1/client-%2.xpm", status_icons_dir, "up-to-date"),

	// repositories
	"repo-up-to-date"	: sformat ("%1/repo-%2.xpm", status_icons_dir, "up-to-date"),
	"repo-not-up-to-date"	: sformat ("%1/repo-%2.xpm", status_icons_dir, "not-up-to-date"),
    ];

    map <string, string> smt_patch_icons = $[
	// current status
	"a"	: sformat ("%1/patch-%2.xpm", status_icons_dir, "used"),
	"f"	: sformat ("%1/patch-%2.xpm", status_icons_dir, "not-used"),

	// current action (to be removed, to be used)
	"-"	: sformat ("%1/patch-%2.xpm", status_icons_dir, "remove"),
	"+"	: sformat ("%1/patch-%2.xpm", status_icons_dir, "use"),
    ];

    // patch categories translation map
    map <string, string> patch_categories = $[
	// Patch category
	"recommended"	: _("Recommended"),
	// Patch category
	"optional"	: _("Optional"),
	// Patch category
	"security"	: _("Security"),
    ];

    // BNC #513169
    // Selective mirroring in YaST should be logged to a default location
    string default_mirrroring_log = "/var/log/smt/smt-mirror.log";

    term CredentialsDialogContent () {
        return `HBox (
            `HStretch(),
                      `HSquash (
                          `VBox (
                              `VWeight(2, `VStretch()),
                                 // TRANSLATORS: check box
                                 `Left (`CheckBox (`id ("enable_smt_service"), _("&Enable Subscription Management Tool Service (SMT)"))),
                                 `Left ("firewall"),

                                 `VWeight(1, `VStretch()),
                                 `Left (`Frame (_("Customer Center Configuration"), (`VBox (
                                     `HSquash (`MinWidth (
                                         40,
                                         `RadioButtonGroup (`id(`protocol),
                                                        `HBox (`HSpacing (0.2),
                                                               `RadioButton(`id("scc"), `opt (`notify),
                                                                            // radio button label
                                                                            _("SCC")),
                                                               `RadioButton(`id("ncc"), `opt (`notify),
                                                                            // radio button label
                                                                            _("NCC"))
                                                        ))
                                     )),
				     `HSquash (`MinWidth (
					40,
					// TRANSLATORS: check box
					`CheckBox (`id ("custom"), `opt(`notify), _("&Use Custom Server"))
				     )),
                                     `HSquash (`MinWidth (
                                         40,
                                         // TRANSLATORS: text entry
                                         `InputField (`id ("NURegUrl"), _("&Registration Server Url"))
                                     )),
                                     `HSquash (`MinWidth (
                                         40,
                                         // TRANSLATORS: text entry
                                         `InputField (`id ("NUUrl"), _("&Download Server Url"))
                                     )),
                                     `HSquash (`MinWidth (
                                         40,
                                         // TRANSLATORS: text entry (User name)
                                         `InputField (`id ("NUUser"), _("&User"))
                                     )),
                                     `HSquash (`MinWidth (
                                         40,
                                         // TRANSLATORS: password entry
                                         `Password (`id ("NUPass"), _("&Password"))
                                     )),
                                     `VSpacing (1),
                                     // TRANSLATORS: push button
                                     `PushButton (`id ("test_NU_credentials"), `opt(`key_F6), _("&Test..."))
                                 )))),
                                 `VWeight(1, `VStretch()),
                                 `Left (`HSquash (`MinWidth (
                                     45,
                                     // TRANSLATORS: text entry (e-mail)
                                     `InputField (`id ("nccEmail"), _("&NCC E-mail Used for Registration"))
                                 ))),
                                 `Left (`HSquash (`MinWidth (
                                     45,
                                     // TRANSLATORS: text entry (URL)
                                     `InputField (`id ("url"), _("&Your SMT Server URL"))
                                 ))),
                                 `VWeight(1, `VStretch()),
                                 `VWeight(2, `VStretch())
                          )
                      ),
                      `HStretch()
        );
    }

    term DatabaseDialogContent () {
	return `HBox (
	    `HStretch(),
	    `HSquash (
		`VBox (
		    `VStretch(),

		    `Left (`HSquash (`MinWidth (
			40,
			// TRANSLATORS: password entry
			`Password (`id ("DB-password-1"), _("Database &Password"))
		    ))),
		    `Left (`HSquash (`MinWidth (
			40,
			// TRANSLATORS: password entry
			`Password (`id ("DB-password-2"), _("C&onfirm Password"))
		    ))),

		    `VStretch()
		)
	    ),
	    `HStretch()
	);
    }

    term ScheduledDownloadsDialogContent () {
	return `VBox (
	    `Left(`Label (_("List of Scheduled Jobs"))),
	    `Table (
		`id ("scheduled_NU_mirroring"),
		`opt (`vstretch),
		`header (
		    _("Job to Run"),
		    // TRANSLATORS: table header item
		    _("Frequency"),
		    // TRANSLATORS: table header item
		    _("Day of the Week"),
		    // TRANSLATORS: table header item
		    _("Day of the Month"),
		    // TRANSLATORS: table header item
		    _("Hour"),
		    // TRANSLATORS: table header item
		    _("Minute")
		),
		[]
	    ),
	    `Left (`HBox (
		`PushButton (`id (`add),	`opt(`key_F3), _("&Add...")),
		`PushButton (`id (`edit),	`opt(`key_F4), _("&Edit...")),
		`PushButton (`id (`delete),	`opt(`key_F5), Label::DeleteButton())
	    ))
	);
    }

    term ReportEmailTableContent () {
	return `HBox (
	    `HStretch (),
	    `HSquash (`MinWidth( 40, `VBox (
		`Table (
		    `id (`report_table),
		    `header (
			_("E-mail addresses to send reports to")
		    ),
		    []
		),
		`Left (
		    `HBox (
			`PushButton (`id (`add), _("&Add...")),
			`PushButton (`id (`edit), Label::EditButton()),
			`PushButton (`id (`delete), Label::DeleteButton())
		    )
		)
	    ))),
	    `HStretch()
	);
    }

    list <term> GetPatchCategoryItems () {
	list <term> items = maplist (string id, string localized, patch_categories, {
	    return `item (`id (id), localized);
	});

	items =  sort (term x, term y, items, {
	    return (x[1]:"" < y[1]:"");
	});

	return prepend (items, `item (`id ("all"), _("All")));
    }

    void ResetPatchCategoryFilter () {
	UI::ChangeWidget (`id (`category_filter), `Value, "all");
    }

    string GetSelectedPatchFilter () {
	string selected_filter = (string) UI::QueryWidget (`id (`category_filter), `Value);

	if (selected_filter == nil || selected_filter == "all")
	    selected_filter = "";

	return selected_filter;
    }

    term StagingTableContent () {
	return `VBox (
	    `HBox (
		`HSquash (`HBox (
		    `ReplacePoint (`id (`catalogs_rp), `ComboBox (`id (`catalogs), _("Repository &Name"), [])),
		    `ComboBox (`id (`category_filter), `opt (`notify), _("&Patch Category"), GetPatchCategoryItems())
		)),
		`HStretch(),
		`VBox (`ReplacePoint (`id (`repo_details), `Empty()))
	    ),
	    `Table (
		`id (`patches_table),
		`opt (`hstretch, `vstretch, `notify, `immediate),
		`header (
		    _("Patch Name"),
		    _("Version"),
		    _("Category"),
		    _("Testing"),
		    _("Production"),
		    _("Summary")
		),
		[]
	    ),
	    `HBox (
		`Label (_("Patch Details")),
		`HStretch(),
		`ReplacePoint (`id (`patches_table_rp), `Empty())
	    ),
	    `VSquash (`MinHeight (4, `RichText (`id (`patch_details), ""))),
	    `Left (
		`HBox (
		    `PushButton (`id (`toggle_patch_status), _("&Toggle Patch Status")),
		    `HStretch(),
		    `MenuButton (`id (`change_status), _("Change &Status"), [
			`item (`id (`additional_filters),	_("&Exclude from Snapshot...")),
			`menu (`id (`all_listed), _("&All listed..."), [
			    `item (`id (`all_listed_enable),	_("&Enable")),
			    `item (`id (`all_listed_disable),	_("&Disable")),
			]),
		    ]),
		    `MenuButton (`id (`create_snapshot), _("Create Snapshot..."), [
			`item (`id (`create_snapshot_testing),		_("From Full Mirror to &Testing")),
			`item (`id (`create_snapshot_production),	_("From Testing to &Production")),
		    ])
		)
	    )
	);
    }

    term CatalogsTableContent () {
	return `VBox (
	    `Left (`ReplacePoint (`id (`catalogs_filter), `Empty())),
	    `Table (
		`id (`catalogs_table),
		`opt (`hstretch, `vstretch, `notify, `immediate),
		`header (
		    _("Name"),
		    _("Target"),
		    _("Mirroring"),
		    _("Staging"),
		    _("Mirrored"),
		    _("Description")
		),
		[]
	    ),
	    `Left (
		`HBox (
		    `PushButton (`id (`toggle_mirroring), _("Toggle &Mirroring")),
		    `PushButton (`id (`toggle_staging), _("Toggle &Staging")),
		    `HStretch(),
		    `PushButton (`id (`mirror_now), _("Mirror &Now"))
		)
	    )
	);
    }

    term ClientsTableContent () {
	return `VBox (
	    `Left (`ReplacePoint (`id (`clients_filter), `Empty())),
	    `Table (
		`id (`clients_table),
		`opt (`hstretch, `vstretch, `notify, `immediate),
		`header (
		    _("Status"),
		    _("Host Name"),
		    _("Last Contact")
		),
		[]
	    ),
	    `VSquash (`MinHeight (5, `RichText (`id (`client_details), "")))
	);
    }

    symbol ReadDialog() {
	// Checking for root's permissions
	if (!Confirm::MustBeRoot())
	    return `abort;

	Progress::New (
	    // TRANSLATORS: Dialog caption
	    _("Initializing SMT Configuration"),
	    " ",
	    4,
	    [
		// TRANSLATORS: Progress stage
		_("Read SMT configuration"),
		// TRANSLATORS: Progress stage
		_("Read SMT status"),
		// TRANSLATORS: Progress stage
		_("Read firewall settings"),
		// TRANSLATORS: Progress stage
		_("Read cron settings"),
	    ],
	    [
		// TRANSLATORS: Bussy message /progress/
		_("Reading SMT configuration..."),
		// TRANSLATORS: Bussy message /progress/
		_("Reading SMT status..."),
		// TRANSLATORS: Bussy message /progress/
		_("Reading firewall settings..."),
		// TRANSLATORS: Bussy message /progress/
		_("Reading cron settings..."),
		Message::Finished(),
	    ],
	    ""
	);
	Wizard::SetTitleIcon("yast-smt");
	Wizard::RestoreHelp(HELPS["read"]:"");

	Progress::NextStage();
	sleep (sl);

	SMTData::ReadCredentials();
	SMTData::ReadFirstRun();
	SMTData::StorePasswordTMP();

	Progress::NextStage();
	sleep (sl);

	boolean orig = Progress::set (false);
	RunlevelEd::Read();
	Progress::set (orig);

	SMTData::ReadSMTServiceStatus();

	Progress::NextStage();
	sleep (sl);

	orig = Progress::set (false);
	SuSEFirewall::Read();
	Progress::set (orig);

	Progress::NextStage();
	sleep (sl);

	SMTData::ReadCronSettings();
	SMTData::CronRandomize();

	Progress::NextStage();
	sleep (sl);

	Progress::Finish();

	return `next;
    }

    symbol RegisterOrFillUpCredentials () {
	Wizard::SetContents (
	    // Dialog caption
	    _("NCC Credentials"),
	    `HSquash (`VBox (
		// Informative text
		`Label (_("System does not appear to be registered in NCC.
Choose one of the options below.")),
		`VSpacing (1),
		`RadioButtonGroup (
		    `id ("NCCCredentialsRBB"),
		    `opt (`notify),
		    `HBox (
			`HSpacing (2),
			`VBox (
			    // Radio button
			    `Left (`RadioButton (`id ("skip"),		`opt (`notify), _("&Skip Registration"))),
			    `VSpacing (1),
			    // Radio button
			    `Left (`RadioButton (`id ("registration"),	`opt (`notify), _("Register in &Novell Customer Center"))),
			    `VSpacing (1),
			    // Radio button
			    `Left (`RadioButton (`id ("generate"),	`opt (`notify), _("&Generate New NCC Credentials"))),
			    `VSpacing (1)
			)
		    )
		)
	    )),
	    // Help "NCC Credentials", #1
	    _("<p><b><big>NCC Credentials</big></b><br>
You need to register your SMT in Novell Customer Center to get it working
properly. Choose one of the listed options.</p>") +
	    // Help "NCC Credentials", #2
	    _("<p>Choosing <b>Register in Novell Customer Center</b> would
call regular Novell Customer Center Configuration module,
<b>Generate New NCC Credentials</b> just creates new NCC Credentials
file without calling Novell Customer Center Configuration module.</p>"),
	    true,
	    true
	);
	Wizard::SetTitleIcon ("registration");

	any dialog_ret = nil;
	symbol ret = `next;

	// Initial dialog settings
	string decision = "registration";
	UI::ChangeWidget (`id ("NCCCredentialsRBB"), `CurrentButton, decision);

	while (true) {
	    dialog_ret = UI::UserInput();

	    if (dialog_ret == `next) {
		decision = (string) UI::QueryWidget (`id ("NCCCredentialsRBB"), `CurrentButton);
		y2milestone ("User decision: %1", decision);
		if (decision == "skip") {
		    if (Popup::AnyQuestion (
			// Pop-up dialog caption
			_("Warning"),
			// Pop-up question
			_("Leaving the NCC credentials empty might cause SMT not to work properly.
Are you sure you want to really skip it?"),
			// Button label
			_("&Yes, Skip It"),
			// Button label
			_("&Cancel"),
			`focus_no
		    )) {
			y2warning ("User decided to skip registration or entering NCC credentials");
			ret = `next;
		    } else {
			continue;
		    }
		} else if (decision == "registration") {
		    any wfmret = WFM::CallFunction ("inst_suse_register");
		    y2milestone ("inst_suse_register returned: %1", wfmret);
		    ret = `again;
		} else if (decision == "generate") {
		    // Busy message
		    boolean dopen = (boolean) UI::OpenDialog (`Label (_("Generating NCCcredentials...")));
		    any check_ret = WFM::CallFunction ("smt_generate_new_credentials");
		    if (dopen == true) UI::CloseDialog();
		    if (check_ret == nil) {
			// Error pop-up, %1 is replaced with a script name
			Report::Error (sformat(_("Unable to generate new NCCcredentials,
An error occurred while calling %1"), "smt_generate_new_credentials"));
			continue;
		    }
		}
		break;
	    } else if (dialog_ret == `back) {
		ret = `back;
		break;
	    } else if (dialog_ret == "skip" || dialog_ret == "registration" || dialog_ret == "generate") {
		decision = (string) UI::QueryWidget (`id ("NCCCredentialsRBB"), `CurrentButton);
	    } else if (dialog_ret == `abort || dialog_ret == `cancel) {
		if (Popup::ReallyAbort (true)) {
		    ret = `abort;
		    break;
		}
	    } else {
		y2error ("Unknown user input: %1", dialog_ret);
	    }
	}

	return ret;
    }

    // FATE #305541, Check if NCCcredentials file exists and offer registration
    // or creating the file if it doesn't
    symbol CheckConfigDialog () {
	// defualt dialog return
	symbol dialog_ret = `next;

	if (SMTData::GetSMTServiceStatus () != true) {
	    y2milestone ("SMT Service is not enabled, not checking the config");
	    return dialog_ret;
	}

	while (SMTData::SystemIsRegistered() != true) {
	    y2warning ("No NCCcredentials present, offering registration, etc.");
	    dialog_ret = RegisterOrFillUpCredentials();
	    y2milestone ("Dialog ret: %1", dialog_ret);

	    if (dialog_ret == `abort || dialog_ret == `back || dialog_ret == `next) {
		break;
	    }
	}

	// Check succeeded after some iterations...
	if (dialog_ret == `again) {
	    dialog_ret = `next;
	// Aborted? Skip the other tests
	} else if (dialog_ret == `abort) {
	    return dialog_ret;
	}

	if (SMTData::CheckAndAdjustCredentialsFileAccess() != true) {
	    Report::Error (sformat (
		// Pop-up error message, %1 is replaced with file name, %2 with username
		_("SMT is unable to set %1 file permissions
to be readable by %2 user."),
		SMTData::GetNCCcredentialsFile(),
		SMTData::GetCredentials ("DB", "user")
	    ));
	}

	return dialog_ret;
    }

    void CheckAlreadyMirroredRepositories () {
	if (SMTData::CheckAndAdjustMirroredReposAccess() != true) {
	    Report::Error (sformat (
		// Pop-up error message, %1 is replaced with directory name, %2 with username
		_("SMT is unable to set %1 directory permission
to be recursively writable by %2 user."),
		SMTData::GetMirroredReposDirectory(),
		SMTData::GetCredentials ("DB", "user")
	    ));
	}
    }

    void WritePatches () {
	// Writing the patches filters, storing to database
	y2milestone ("Writing patches...");
	boolean success = SCR::Write (.smt.staging.patches, nil);
	y2milestone ("Writing patches returned: %1", success);
    }

    boolean CheckRobotsTXT () {
	string mirror_to = SMTData::GetCredentials ("LOCAL", "MirrorTo");

	if (mirror_to == nil || mirror_to == "") {
	    y2error ("Wrong LOCAL->MirrorTo");
	    return nil;
	}

	mirror_to = mirror_to + "/robots.txt";

	if (! FileUtils::Exists (mirror_to)) {
	    return true;
	}

	// Checking for
	string cmd = sformat ("grep '^Allow:[ \\t]\\+/\\?repo/keys/\\?' '%1'", mirror_to);
	integer cmd_ret = (integer) SCR::Execute (.target.bash, cmd);

	// 0 -> some lines found
	// 1 -> nothing found
	// 2 -> error
	if (cmd_ret == 2) {
	    y2warning ("Cannot check robots.txt");
	    return false;
	} else if (cmd_ret == 0) {
	    y2milestone ("File robots.txt seem to allow /repo/keys");
	    return true;
	}

	y2warning ("File robots.txt found! (cmd ret: %1)", cmd_ret);
	Report::Warning (sformat(_("File %1 has been found in your document root.

Please, make sure, that '/repo/keys' is listed as an allowed directory
or remove the file. Otherwise SMT server might not work properly."), mirror_to));

	return false;
    }

    symbol WriteDialog() {
	list<string> stages = [
                // TRANSLATORS: Progress stage
                _("Adjust SMT configuration"),
                // TRANSLATORS: Progress stage
                _("Adjust database configuration"),
                // TRANSLATORS: Progress stage
                _("Migrate the customer center"),
                // TRANSLATORS: Progress stage
                _("Check and install server certificate"),
                // TRANSLATORS: Progress stage
                _("Adjust Web-server configuration"),
                // TRANSLATORS: Progress stage
                _("Adjust SMT service"),
                // TRANSLATORS: Progress stage
                _("Write firewall settings"),
                // TRANSLATORS: Progress stage
                _("Write cron settings"),
                // TRANSLATORS: Progress stage
                _("Check mirrored repositories"),
                // TRANSLATORS: Progress stage
                _("Run synchronization check"),
	];
	list<string> steps = [
                // TRANSLATORS: Bussy message /progress/
                _("Adjusting SMT configuration..."),
                // TRANSLATORS: Bussy message /progress/
                _("Adjusting database configuration..."),
                // TRANSLATORS: Bussy message /progress/
                _("Migrating the customer center..."),
                // TRANSLATORS: Bussy message /progress/
                _("Checking and installing server certificate..."),
                // TRANSLATORS: Bussy message /progress/
                _("Adjusting Web server configuration..."),
                // TRANSLATORS: Bussy message /progress/
                _("Adjusting SMT service..."),
                // TRANSLATORS: Bussy message /progress/
                _("Writing firewall settings..."),
                // TRANSLATORS: Bussy message /progress/
                _("Writing cron settings..."),
                // TRANSLATORS: Bussy message /progress/
                _("Checking mirrored repositories..."),
                // TRANSLATORS: Bussy message /progress/
                _("Running synchronization check..."),
                Message::Finished(),
	];

	if (! SMTData::ApiTypeChanged())
	{
	    stages[2] = nil;
	    steps[2] = nil;
	    stages = filter (string s, stages, ``{ return s != nil; });
	    steps = filter (string s, steps, ``{ return s != nil; });
	}

	Progress::New (
	    // TRANSLATORS: Dialog caption
	    _("Writing SMT Configuration"),
	    " ",
	    size(stages),
	    stages,
	    steps,
	    ""
	);

	Wizard::SetTitleIcon("yast-smt");
	Wizard::RestoreHelp(HELPS["write"]:"");

	SMTData::WriteCredentials();

	Progress::NextStage();
	sleep (sl);

	Progress::NextStage();
	sleep (sl);

	// uses credentials
	SMTData::StartDatabaseIfNeeded();
	SMTData::WriteDatabaseSettings();
	SMTData::ChangePasswordIfDifferent();

	if (SMTData::ApiTypeChanged())
	{
	    Progress::NextStage();
	    sleep (sl);
	    SMTData::MigrateCustomerCenter();
	}

	Progress::NextStage();
	sleep (sl);

	SMTData::WriteCASettings();

	Progress::NextStage();
	sleep (sl);

	SMTData::CheckAndAdjustApacheConfiguration();

	CheckRobotsTXT();

	Progress::NextStage();
	sleep (sl);

	SMTData::WriteSMTServiceStatus();

	Progress::NextStage();
	sleep (sl);

	boolean orig = Progress::set (false);
	SuSEFirewall::Write();
	Progress::set (orig);

	Progress::NextStage();
	sleep (sl);

	SMTData::WriteCronSettings();

	Progress::NextStage();
	sleep (sl);

	SMTData::WriteFirstRunStatus();
	sleep (sl);

	Progress::NextStage();

	// BNC #521013: Checking uses smt agent that connects to database
	// Database has to be already running
	CheckAlreadyMirroredRepositories();

	Progress::NextStage();

	if (SMTData::GetSMTServiceStatus() == true) {
	    SMTData::RunSmallSync();
	}

	Progress::Finish();

	return `next;
    }

    symbol ReadManagementDialog () {
	Progress::New (
	    // TRANSLATORS: Dialog caption
	    _("Initializing SMT Configuration"),
	    " ",
	    1,
	    [
		// TRANSLATORS: Progress stage
		_("Read SMT configuration"),
		// TRANSLATORS: Progress stage
	    ],
	    [
		// TRANSLATORS: Bussy message /progress/
		_("Reading SMT configuration..."),
		Message::Finished(),
	    ],
	    ""
	);
	Wizard::SetTitleIcon("yast-smt");
	Wizard::RestoreHelp(HELPS["read"]:"");

	Progress::NextStage();

	SMTData::ReadCredentials();

	Progress::Finish();

	return `next;
    }

    symbol WriteManagementDialog() {
	Progress::New (
	    // TRANSLATORS: Dialog caption
	    _("Writing Changes"),
	    " ",
	    1,
	    [
		// TRANSLATORS: Progress stage
		_("Write patches"),
	    ],
	    [
		// TRANSLATORS: Bussy message /progress/
		_("Writing patches..."),
		Message::Finished(),
	    ],
	    ""
	);
	Wizard::SetTitleIcon("yast-smt");
	Wizard::RestoreHelp(HELPS["write"]:"");

	Progress::NextStage();

	WritePatches();

	Progress::Finish();

	return `next;
    }

    void InitCredentialsDialog (string id) {
	foreach (string one_entry, ["NUUser", "NUPass", "NURegUrl", "NUUrl"], {
	    string value = SMTData::GetCredentials ("NU", one_entry);
	    if (value == nil) value = "";
	    UI::ChangeWidget (`id (one_entry), `Value, value);
	});

	foreach (string one_entry, ["nccEmail", "url"], {
	    string value = SMTData::GetCredentials ("LOCAL", one_entry);
	    if (value == nil) value = "";
	    UI::ChangeWidget (`id (one_entry), `Value, value);
	});

	// BNC #514304
	// Using fallback FQDN if no URL is set in configuration
	if (SMTData::GetCredentials ("LOCAL", "url") == "") {
	    string value = Hostname::CurrentFQ();

	    if (value != nil) {
		if (regexpmatch (value, ".*[ \t\n]+.*")) value = regexpsub (value, "(.*)[ \t\n]+.*", "\\1");

		if (size (value) > 0) {
		    value = sformat ("http://%1/", value);
		    y2milestone ("Using '%1'", value);
		    UI::ChangeWidget (`id ("url"), `Value, value);
		}
	    }
	}

	string regurl = SMTData::GetCredentials ("NU", "NURegUrl");
	string api_type = SMTData::GetCredentials ("NU", "ApiType");
	if (regurl == "https://scc.suse.com/connect" || String::StartsWith(regurl, "https://secure-www.novell.com/center/regsvc"))
	{
	    UI::ChangeWidget (`id ("custom"), `Value, false);
	    UI::ChangeWidget (`id ("NURegUrl"), `Enabled, false);
	    UI::ChangeWidget (`id ("NUUrl"), `Enabled, false);
	}
	else
	{
	    UI::ChangeWidget (`id ("custom"), `Value, true);
	    UI::ChangeWidget (`id ("NURegUrl"), `Enabled, true);
	    UI::ChangeWidget (`id ("NUUrl"), `Enabled, true);
	}

        if (api_type == "SCC")
	{
            UI::ChangeWidget (`id (`protocol), `CurrentButton, "scc");
        }
        else
	{
            UI::ChangeWidget (`id (`protocol), `CurrentButton, "ncc");
        }
	UI::ChangeWidget (`id ("enable_smt_service"), `Value, SMTData::GetSMTServiceStatus());
    }

    void StoreCredentialsDialog (string id, map event) {
	foreach (string one_entry, ["NUUser", "NUPass", "NURegUrl", "NUUrl"], {
	    SMTData::SetCredentials ("NU", one_entry, (string) UI::QueryWidget (`id (one_entry), `Value));
	});

	foreach (string one_entry, ["nccEmail", "url"], {
	    SMTData::SetCredentials ("LOCAL", one_entry, (string) UI::QueryWidget (`id (one_entry), `Value));
	});

        if (UI::QueryWidget (`id (`protocol), `CurrentButton) == "scc") {
            SMTData::SetCredentials ("NU", "ApiType", "SCC");
        } else {
            /* SLMS "speak" NCC protocol */
            SMTData::SetCredentials ("NU", "ApiType", "NCC");
        }
	boolean new_service_status = (boolean) UI::QueryWidget (`id ("enable_smt_service"), `Value);
	y2milestone ("New SMT status: %1", (new_service_status == true ? "enabled":"disabled"));
	SMTData::SetSMTServiceStatus (new_service_status);
    }

    void InitDatabaseDialog (string id) {
	string value = SMTData::GetCredentials ("DB", "pass");
	if (value == nil) value = "";

	// bnc #390085
	UI::ChangeWidget (`id ("DB-password-1"), `Label,
	    sformat ("Database Password for %1 User", SMTData::GetCredentials ("DB", "user"))
	);
	UI::ChangeWidget (`id ("DB-password-2"), `Label,
	    sformat ("Database Password for %1 User Once Again", SMTData::GetCredentials ("DB", "user"))
	);

	UI::ChangeWidget (`id ("DB-password-1"), `Value, value);
	UI::ChangeWidget (`id ("DB-password-2"), `Value, value);
    }

    void StoreDatabaseDialog (string id, map event) {
	SMTData::SetCredentials ("DB", "pass", (string) UI::QueryWidget (`id ("DB-password-1"), `Value));
    }

    boolean ValidateDatabaseDialog (string id, map event) {
	string pass_1 = (string) UI::QueryWidget (`id ("DB-password-1"), `Value);
	string pass_2 = (string) UI::QueryWidget (`id ("DB-password-2"), `Value);

	if (pass_1 != pass_2) {
	    UI::SetFocus (`id ("DB-password-1"));
	    // TRANSLATORS: error report
	    Report::Error (_("The first and the second password do not match."));
	    return false;
	}

	// pass_1 and pass_2 are equal
	if (pass_1 == nil || pass_1 == "") {
	    UI::SetFocus (`id ("DB-password-1"));
	    // TRANSLATORS: error report, actually containing a question
	    if (! Popup::ContinueCancel (_("Password should not be empty.

Would you like to continue nevertheless?")))
		return false;
	}

	y2milestone ("Password validation passed");
	return true;
    }

    boolean ValidateCredentialsDialog (string id, map event) {
	string orig_url = SMTData::GetCredentials ("NU", "NURegUrl");
        boolean was_scc = (orig_url == "https://scc.suse.com/connect");
	boolean is_scc = (UI::QueryWidget (`id (`protocol), `CurrentButton) ==  "scc");
        y2milestone ("Previous CC: %1, new CC: %2, initial config: %3", was_scc, is_scc, SMTData::InitialConfig());
	if (SMTData::InitialConfig())
	{
	    y2milestone ("Initial configuration, skipping migration checks");
	}
	else if (is_scc && ! was_scc)
	{
	    Popup::ShowFeedback("", "Checking if migration to SCC is possible...");
	    integer test_ret = (integer)SCR::Execute (.target.bash, "/usr/sbin/smt-ncc-scc-migration --check-only");
	    Popup::ClearFeedback();
	    if (test_ret != 0)
	    {
		// report message
		Report::Message(_("Cannot migrate SMT to SCC because not all products,
which are registered against this instance of SMT,
are available also via SCC."));
		return false;
	    }
	    // continue / cancel pop-up
	    if (! Popup::ContinueCancel(_("The migration to SCC will take some time, during which
SMT will not be able to serve its clients. After
the migration is finished, you will be able to serve
only products available in SCC.

Migrate SMT from NCC to SCC now?")))
	    {
		return false;
	    }
	}
	else if (was_scc && ! is_scc)
	{
	    Popup::ShowFeedback("", "Checking if migration to NCC is possible...");
	    integer test_ret = (integer)SCR::Execute (.target.bash, "smt-scc-ncc-migration --check-only");
	    Popup::ClearFeedback();
	    if (test_ret != 0)
	    {
		// report message
		Report::Message(_("Cannot migrate SMT to NCC because not all products,
which are registered against this instance of SMT,
are available also via NCC."));
		return false;
	    }
	    // continue / cancel pop-up
	    if (! Popup::ContinueCancel(_("You are about to switch this instance of SMT from SCC
back to NCC. SCC is the default registration server
for SUSE products. Using SCC is recommended.

The migration to NCC will take some time, during which
SMT will not be able to serve its clients. After
the migration is finished, you will be able to serve
SUSE products released before September 2014.
SUSE products released after September 2014 will not
be available.

Migrate SMT from SCC to NCC now?")))
	    {
		return false;
	    }
	}

	string url = (string) UI::QueryWidget (`id ("url"), `Value);

	if (url == nil || url == "") {
	    UI::SetFocus (`id ("url"));
	    // Pop-up error message
	    Report::Error (_("The SMT URL must not be empty.

Enter your SMT server URL in the following format: http:://server.name/
"));
	    return false;
	// BNC #518222: Check for 'http://.+' or 'https://.+' in URL
	} else if (! regexpmatch (url, "^\[ \t\]*http://.\+") && ! regexpmatch (url, "^\[ \t\]*https://.\+")) {
	    UI::SetFocus (`id ("url"));
	    Report::Error (_("Invalid SMT Server URL.

URL should start with 'http://' or 'https://'."));
	    return false;
	}

	string nuuser = (string) UI::QueryWidget (`id ("NUUser"), `Value);
	if (nuuser == nil || nuuser == "") {
	    UI::SetFocus (`id ("NUUser"));
	    // Pop-up error message
	    Report::Error (_("NU User must not be empty."));
	    return false;
	}

	string nupass = (string) UI::QueryWidget (`id ("NUPass"), `Value);
	if (nupass == nil || nupass == "") {
	    UI::SetFocus (`id ("NUPass"));
	    // Pop-up error message
	    Report::Error (_("NU Password must not be empty."));
	    return false;
	}

	return true;
    }

    boolean TestCredentials () {
	UI::OpenDialog (`MinSize (52, 12, `VBox (
	    // TRANSLATORS: LogView label
	    `LogView (`id ("test_log"), _("&Test Details"), 5, 100),
	    `VSpacing (1),
	    `PushButton (`id (`ok), `opt (`default, `key_F10), Label::OKButton())
	)));

	// complex.ycp
	boolean ret = CredentialsTest ("test_log");

	if (ret == true) {
	    // TRANSLATORS: LogView line
	    UI::ChangeWidget (`id ("test_log"), `LastLine, "\n" + _("Test result: success") + "\n");
	} else {
	    // TRANSLATORS: LogView line
	    UI::ChangeWidget (`id ("test_log"), `LastLine, "\n" + _("Test result: failure") + "\n");
	}

	UI::UserInput();
	UI::CloseDialog();

	return ret;
    }

    symbol HandleCredentialsDialog (string id, map event) {
	any action = event["ID"]:nil;
	boolean custom = (boolean)UI::QueryWidget (`id ("custom"), `Value);
	string cc = (string)UI::QueryWidget (`id (`protocol), `CurrentButton);

	if (action == "test_NU_credentials") {
	    StoreCredentialsDialog (id, event);
	    TestCredentials();
	}
	else if (action == "scc") {
	    if (! custom)
	    {
	        UI::ChangeWidget (`id ("NURegUrl"), `Value, "https://scc.suse.com/connect");
	        UI::ChangeWidget (`id ("NUUrl"), `Value, "https://updates.suse.com/");
	    }
        }
        else if (action == "ncc") {
	    if (! custom)
	    {
	        UI::ChangeWidget (`id ("NURegUrl"), `Value, "https://secure-www.novell.com/center/regsvc/");
	        UI::ChangeWidget (`id ("NUUrl"), `Value, "https://nu.novell.com/");
	    }
        }
        else if (action == "custom") {
	    if ((boolean)UI::QueryWidget (`id ("custom"), `Value))
	    {
	        UI::ChangeWidget (`id ("NURegUrl"), `Enabled, true);
	        UI::ChangeWidget (`id ("NUUrl"), `Enabled, true);
	        UI::ChangeWidget (`id ("NURegUrl"), `Value, "");
	        UI::ChangeWidget (`id ("NUUrl"), `Value, "");
	    }
	    else
	    {
	        UI::ChangeWidget (`id ("NURegUrl"), `Enabled, false);
	        UI::ChangeWidget (`id ("NUUrl"), `Enabled, false);
	        UI::ChangeWidget (`id ("NURegUrl"), `Value, cc == "scc"
		    ? "https://scc.suse.com/connect"
		    : "https://secure-www.novell.com/center/regsvc/");
	        UI::ChangeWidget (`id ("NUUrl"), `Value, cc == "scc"
		    ? "https://updates.suse.com/"
		    : "https://nu.novell.com/");

	    }
        }

	return nil;
    }

    list <string> report_e_mails = [];

    void InitReportEmails () {
	string reportEmail = SMTData::GetCredentials ("REPORT", "reportEmail");

	if (reportEmail == nil) {
	    y2warning ("REPORT/reportEmail not defined yet");
	    reportEmail = "";
	}

	reportEmail = mergestring (splitstring (reportEmail, " \t"), "");
	report_e_mails = (list <string>) toset (
	    splitstring (reportEmail, ",")
	);
    }

    void StoreReportEmails () {
	SMTData::SetCredentials ("REPORT", "reportEmail", mergestring (report_e_mails, ","));
    }

    void RedrawReportEmailsTable () {
	list <term> items = maplist (string one_email, report_e_mails, {
	    return `item (`id (one_email), one_email);
	});

	UI::ChangeWidget (`id (`report_table), `Items, items);

	boolean edit_delete_stat = (size (items) > 0);
	UI::ChangeWidget (`id (`edit), `Enabled, edit_delete_stat);
	UI::ChangeWidget (`id (`delete), `Enabled, edit_delete_stat);
    }

    void InitReportEmailTableDialog (string id) {
	InitReportEmails();
	RedrawReportEmailsTable();
    }

    void StoreReportEmailTableDialog (string id, map event) {
	StoreReportEmails();
    }

    string yes = UI::Glyph (`CheckMark);
    // opposite to check-mark used in UI, usually not translated
    string no	= _("-");

    map <string, map <string, any> > catalogs_info = $[];

    integer current_filter_level = -1;

    void AdjustRepositoriesButtons () {
	string current_item = (string) UI::QueryWidget (`id (`catalogs_table), `CurrentItem);

	// nothing listed / nothing selected
	if (current_item == nil || current_item == "")
	    return;

	// [Mirror Now]
	boolean new_status_mirror = catalogs_info[current_item, "mirroring"]:true;
	UI::ChangeWidget (`id (`mirror_now), `Enabled, new_status_mirror);

	boolean new_status_staging = (catalogs_info[current_item, "mirroring"]:true
	    || catalogs_info[current_item, "staging"]:true);
	UI::ChangeWidget (`id (`toggle_staging), `Enabled, new_status_staging);
    }

    void RedrawCatalogsTable (list <string> catalogs_filters) {
	y2milestone ("Filter used: %1", catalogs_filters);

	string current_item = (string) UI::QueryWidget (`id (`catalogs_table), `CurrentItem);

	string catalog_filter = nil;
	if (size (catalogs_filters) > 0 && catalogs_filters[size(catalogs_filters)-1]:"" == "")
	    catalogs_filters = remove (catalogs_filters, size(catalogs_filters)-1);
	if (size (catalogs_filters) > 0)
	    catalog_filter = mergestring (catalogs_filters, "-");

	catalogs_info = $[];

	// busy message
	boolean uio = (boolean) UI::OpenDialog (`Label (_("Getting list of the currently available repositories...")));

	map <string, map <string, any> > catalogs_states = (map <string, map <string, any> >) SCR::Read (.smt.repositories.all);
	if (catalogs_states == nil) {
	    y2error ("Error getting available repositories");
	    catalogs_states = $[];
	}

	boolean mirroring = nil;
	boolean staging = nil;

	// Constructing the Filter UI
	// $[0:["openSUSE", "SLE", ...], 1:["11.1", "SDK", ...], ...]
	map <integer, list <string> > filter_items = $[];
	integer max_filter_item = -1;
	boolean current_item_present = false;

	list <term> items = maplist (string catalogid, map <string, any> one_catalog, catalogs_states, {
	    if (catalog_filter != nil) {
		if (regexpmatch (one_catalog["NAME"]:"", "^" + catalog_filter + "-")) {
		    y2debug ("match");
		} else if (one_catalog["NAME"]:"" == catalog_filter) {
                    y2debug ("match");
		} else {
		    return nil;
		}
	    }

	    mirroring	= (one_catalog["DOMIRROR"]:"" == "Y");
	    staging	= (one_catalog["STAGING"]:"" == "Y");

	    integer splititem_nr = -1;
	    // "SLE10-SDK-Updates" -> ["SLE10", "SDK", "Updates"]
	    foreach (string one_item, splitstring (one_catalog["NAME"]:"", "-"), {
		splititem_nr = splititem_nr + 1;

		if (! haskey (filter_items, splititem_nr))
		    filter_items[splititem_nr] = [];
		if (! contains (filter_items[splititem_nr]:[], one_item))
		    filter_items[splititem_nr] = add (filter_items[splititem_nr]:[], one_item);
	    });

	    if (splititem_nr > max_filter_item)
		max_filter_item = splititem_nr;

	    // used later in Handle* function
	    catalogs_info[catalogid] = $[
		"mirroring"	: mirroring,
		"staging"	: staging,
		"name"		: one_catalog["NAME"]:"",
		// empty /--/ == no specific target
		"target"	: (regexpmatch (one_catalog["TARGET"]:"", "^-+$") ? "" : one_catalog["TARGET"]:""),
	    ];

	    if (current_item == one_catalog["ID"]:"")
		current_item_present = true;

	    return `item (
		`id (one_catalog["ID"]:""),
		one_catalog["NAME"]:_("Unknown"),
		one_catalog["TARGET"]:_("Unknown"),
		(mirroring ? yes : no),
		(staging ? yes : no),
		(one_catalog["LAST_MIRROR"]:"" != "" ? one_catalog["LAST_MIRROR"]:"" : no),
		one_catalog["DESCRIPTION"]:""
	    );
	});

	items = filter (term item, items, {
	    return item != nil;
	});

	items = sort (term a, term b, items, ``(a[1]:"" < b[1]:""));

	integer current_item_nr = -1;
	term filter_UI_items = `HBox();
	boolean more_items_lasttime = false;

	while (current_item_nr <= max_filter_item) {
	    current_item_nr = current_item_nr + 1;
	    integer nrofitems = size (filter_items[current_item_nr]:[]);
	    list <term> fitems = maplist (string one_fitem, filter_items[current_item_nr]:[], {
		return `item (`id (one_fitem), one_fitem, (nrofitems == 1));
	    });

	    fitems = sort (term a, term b, fitems, ``(a[1]:"" < b[1]:""));

	    // internal error
	    if (size (fitems) < 1) break;

	    // Add another filter level UI
	    filter_UI_items = add (filter_UI_items,
		`ComboBox (`id (sformat ("catalogs_filter_%1", current_item_nr)), `opt (`notify),
		    // Part of a complex catalogs filter, ComboBox label
		    // %1 is replaced with a filter level number (1 ... n)
		    sformat (_("Filter &%1"), current_item_nr + 1),
		    prepend (
			fitems,
			// Part of a complex catalogs filter, Item: (List) All (Catalogs)
			`item (`id (""), _("All"))
		    )
		)
	    );

	    // More items to choose from, finish
	    if (size (fitems) > 1) break;
	}

	if (items == nil) items = [];

	if (uio == true) UI::CloseDialog();

	if (filter_UI_items == nil || size (filter_UI_items) == 0) {
	    UI::ReplaceWidget (`id (`catalogs_filter),
		`ComboBox (`id (`empty_filter), _("F&ilter"), []));
	    UI::ChangeWidget (`id (`empty_filter), `Enabled, false);
	} else {
	    UI::ReplaceWidget (`id (`catalogs_filter), filter_UI_items);
	}

	UI::ChangeWidget (`id (`catalogs_table), `Items, items);
	if (current_item_present && current_item != nil)
	    UI::ChangeWidget (`id (`catalogs_table), `CurrentItem, current_item);

	AdjustRepositoriesButtons();
    }

    void InitRepositoriesTableDialog (string id) {
	RedrawCatalogsTable ([]);
    }

    string FormatHTMLPatchDescription (string description) {
	integer max = 512;

	while (regexpmatch (description, "\n\n") && max > 0) {
	    max = max - 1;
	    description = regexpsub (description, "(.*)\n\n(.*)", "\\1<br><br>\\2");
	}

	return description;
    }

    /**
     * Stores all the details about the currently listed patches
     *
     * @struct $["patchid" : $[patch_details], ...]
     */
    map <string, map> current_patches = $[];

    /**
     * Currently selected catalog.
     * Variable is filled up when redrawing a table.
     */
    string selected_catalog = "";

    /**
     * Currently selected staging group.
     * Variable is filled up when redrawing a table.
     */
    string selected_staging_group = "default";

    /**
     * Returns whether a patch is filtered by any current 'category' filter.
     *
     * @param string patch ID
     * @return boolean whether filtered
     */
    boolean IsPatchFilteredByType (string patchid) {
	map this_patch = $[
	    "type" : current_patches[patchid, "type"]:"",
	    "repositoryid" : selected_catalog,
            "group" : selected_staging_group,
	];

	return ((boolean) SCR::Read (.smt.staging.category_filter, this_patch) == true);
    }

    string GetTranslatedPatchCategory (string patch_category) {
	// Used as a fallback
	// %1 is replaced with a patch category
	return patch_categories[patch_category]:sformat(_("Patch category '%1'"), patch_category);
    }

    // Only some repositories support filtering, although
    // snapshots can be created from every repository
    boolean filtering_allowed_for_repository = false;

    /**
     * Fills up details widget with the current patch description
     */
    void RedrawPatchesDetails () {
	string sel_patchid = (string) UI::QueryWidget (`id (`patches_table), `CurrentItem);

	// No repositories at all (with staging enabled)
	if (selected_catalog == nil || selected_catalog == "") {
	    UI::ChangeWidget (`id (`patch_details), `Value, "");
	// No patch listed, no patch selected
	} else if (sel_patchid == nil || sel_patchid == "") {
	    UI::ChangeWidget (`id (`patch_details), `Value, _("There are no patches available in this repository."));
	    return;
	}

	// If a patch is filtered by the 'patch type' filter, we don't offer
	// to change it...
	boolean filtered_by_type = IsPatchFilteredByType (sel_patchid);

	boolean buttons_enabled = (filtered_by_type == false && filtering_allowed_for_repository == true);
	UI::ChangeWidget (`id (`toggle_patch_status), `Enabled, buttons_enabled);

	string patch_description = current_patches[sel_patchid,"description"]:"";

	if (filtered_by_type)
	    patch_description = sformat (
		// %1 is replaced with a warning that patch is filtered-out by a category filter
		// %2 is replaced with patch description
		_("%1\n\n%2"),
		sformat (
		    // Connected with the text above, informs user about the current patch state
		    // %1 is replaced with a translated patch type
		    _("<b>Patch is filtered-out by patch-category filter (%1) and thus cannot be enabled in this dialog.</b>"),
		    GetTranslatedPatchCategory (current_patches[sel_patchid, "type"]:"")
		),
		patch_description
	);

	UI::ChangeWidget (
	    `id (`patch_details), `Value,
	    FormatHTMLPatchDescription (patch_description)
	);
    }

    void UpdateRepoDetails () {
	list <string> additional_info = [];

	if (selected_catalog == nil || selected_catalog == "") {
	    additional_info = add (additional_info, _("There are no repositories with staging enabled"));
	} else {
	    map details = (map) SCR::Read(.smt.staging.repository.details, $["repositoryid":selected_catalog,
	                                                                     "group" : selected_staging_group]);

	    additional_info = add (additional_info, sformat (_("Mirror timestamp: %1"),
		((details["full"]:"" != nil && size (details["full"]:"") > 0) ?
		    details["full"]:"" : _("Never mirrored")
		)));

	    additional_info = add (additional_info, sformat (_("Testing snapshot timestamp: %1"),
		((details["testing"]:"" != nil && size (details["testing"]:"") > 0) ?
		    details["testing"]:"" : _("Never created")
		)));

	    additional_info = add (additional_info, sformat (_("Production snapshot timestamp: %1"),
		((details["production"]:"" != nil && size (details["production"]:"") > 0) ?
		    details["production"]:"" : _("Never created")
		)));
	}

	if (size (additional_info) > 0) {
	    UI::ReplaceWidget (`id (`repo_details), `Label (`opt (`boldFont), mergestring (additional_info, "\n")));
	} else {
	    UI::ReplaceWidget (`id (`repo_details), `Empty());
	}
    }

    string GetPatchStatusIcon (map patch) {
	return (patch["testing"]:false ?
	    (patch["filtered"]:false ? "-":"a")
	    :
	    (patch["filtered"]:false ? "f":"+")
	);
    }

    /**
     * Redraws the whole table of patches from the current repository.
     *
     * @param string patch category filter (one of the well known
     * categories ["security", "recommended", "optional"] or "" for no filter used)
     */
    void RedrawPatchesTable (string category_filter) {
	// default
	filtering_allowed_for_repository = false;

        string selected_catalog_group = (string) UI::QueryWidget (`id (`catalogs), `Value);
	// The currently selected catalog
        list<string> l = splitstring(selected_catalog_group, "-");
	selected_catalog = l[0]:"";

        if(size(l) > 2)
        {
            l = remove(l, 0);
            selected_staging_group = mergestring(l, "");
        } else {
            selected_staging_group = l[1]:"default";
        }

	// Better to evaluate boolen (for each patch)
	boolean use_category_filter = (category_filter != nil && category_filter != "");

	// The same current item should be selected after redrawing
	string current_item = (string) UI::QueryWidget (`id (`patches_table), `CurrentItem);
	boolean ci_is_listed = false;

	list <term> items = [];

	if (selected_catalog == nil || selected_catalog == "") {
	    y2milestone ("No catalog selected");
	} else {
	    filtering_allowed_for_repository =
		(boolean) SCR::Read (.smt.repository.staging_allowed, $["repositoryid":selected_catalog]);
	    y2milestone ("Repository %1 filtering allowed: %2", selected_catalog, filtering_allowed_for_repository);

	    current_patches = $[];

	    list <map> patches = (list <map>) SCR::Read (.smt.staging.patches, $["repositoryid":selected_catalog,
                                                                                 "group":selected_staging_group]);
	    if (patches == nil) {
		y2error ("Cannot get patches for catalog: %1", selected_catalog);
	    } else {
		string testing_status = "";
		string production_status = "";

		items = maplist (map one_patch, patches, {
		    // Filtering-out patches not matching the filter
		    if (use_category_filter && category_filter != one_patch["type"]:"")
			return nil;

		    current_patches[one_patch["patchid"]:""] = one_patch;

		    // To select the same current_item again
		    if (! ci_is_listed && one_patch["patchid"]:"" == current_item)
			ci_is_listed = true;

		    testing_status = GetPatchStatusIcon (one_patch);
		    production_status = (one_patch["production"]:false ? "a":"f");

		    return `item (
			`id (one_patch["patchid"]:""),
			one_patch["name"]:"",
			tostring (one_patch["version"]:0),
			GetTranslatedPatchCategory (one_patch["type"]:""),
			(text_mode ? testing_status : `cell (`icon (smt_patch_icons[testing_status]:""))),
			(text_mode ? production_status : `cell (`icon (smt_patch_icons[production_status]:""))),
			one_patch["title"]:""
		    );
		});
	    }
	}

	// If filter is used, remove 'nil's
	if (use_category_filter) {
	    items = filter (term one_item, items, {
		return one_item != nil;
	    });
	}

	items = sort (term a, term b, items, ``(a[1]:"" < b[1]:""));

	boolean any_catalog = (selected_catalog != nil && selected_catalog != "");
	boolean enable_buttons = (size (items) > 0 && filtering_allowed_for_repository == true);

	UI::ChangeWidget (`id (`patches_table), `Items, items);
	UI::ChangeWidget (`id (`toggle_patch_status), `Enabled, enable_buttons);
	UI::ChangeWidget (`id (`change_status), `Enabled, enable_buttons);

	term additional_info = (enable_buttons == true || any_catalog != true ?
	    `Empty():`Label(_("Repository does not allow patch-filtering")));
	UI::ReplaceWidget (`id (`patches_table_rp), additional_info);

	if (ci_is_listed)
	    UI::ChangeWidget (`id (`patches_table), `CurrentItem, current_item);

	RedrawPatchesDetails();
	UpdateRepoDetails();
    }

    map <string, string> known_patch_statuses = $[
	"PATCHSTATUS_P" : _("Package manager patches: %1"),
	"PATCHSTATUS_S" : _("Security patches: %1"),
	"PATCHSTATUS_R" : _("Recommended patches: %1"),
	"PATCHSTATUS_O" : _("Optional patches: %1"),
    ];

    boolean GetPatchStatus (map <string, any> client_info) {
	boolean ret = true;

	foreach (string patch_status, string translation, known_patch_statuses, {
	    if (client_info[patch_status]:nil == nil || client_info[patch_status]:0 > 0) {
		ret = false;
		break;
	    }
	});

	return ret;
    }

    map <integer, map <string, any> > clients_status = $[];

    void RedrawClientsTableDetails () {
	integer current_item = (integer) UI::QueryWidget (`id (`clients_table), `CurrentItem);
	string description = "";

	if (current_item != nil) {
	    map <string, any> client_info = clients_status[current_item]:$[];
	    boolean status = GetPatchStatus (client_info);

	    description = sformat (
		// %1 Client (is|is not) up-to-date
		// %2 There are some patches pending...
		_("%1<br>%2"),
		(status == true ?
		    _("Client is up-to-date")
		    :
		    _("<b>Client is not up-to-date</b>")
		),
		(status != true ?
		    sformat (
			// %1 is replaced with a comma-separated pieces of info, e.g., 'Security patches: 5'
			_("There are some patches pending:<br>%1"),
			// Merges list of pieces of info
			mergestring (maplist (string key, string translation, known_patch_statuses, {
			    // formats one piece of info using a key and translation
			    return sformat (translation, (
				// if the number of patches is defined but nil
				(client_info[key]:0 == nil ?
				    // Number of patches pending
				    _("Status is unknown")
				    :
				    client_info[key]:0
				)
			    ));
			}), ", ")
		    )
		    :
		    ""
		)
	    );
	} else {
	    description = _("There are no registered clients or their status is unknown");
	}

	UI::ChangeWidget (`id (`client_details), `Value, description);
    }

    void RedrawClientsTableDialog () {
	clients_status = (map <integer, map <string, any> >) SCR::Read (.smt.clients.status);

	boolean status = nil;
	string statusstring = nil;

	list <term> items = maplist (integer id, map <string, any> values, clients_status, {
	    status = GetPatchStatus (values);
	    statusstring = values["STATUSSTRING"]:"";

	    return `item (
		`id (id),
		`cell (`icon (smt_status_icons[statusstring]:""), values["STATUSLABEL"]:_("Unknown Status")),
		values["HOSTNAME"]:values["GUID"]:"",
		values["LASTCONTACT"]:_("Never")
	    );
	});

	if (items == nil) items = [];

	items = sort (term a, term b, items, ``(a[1,1]:"" < b[1,1]:""));

	UI::ChangeWidget (`id (`clients_table), `Items, items);

	RedrawClientsTableDetails();
    }

    void InitClientsTableDialog (string id) {
	RedrawClientsTableDialog();
    }

    void RedrawRepositoriesStagingMenu () {
	map <string, map> catalogs = (map <string, map>) SCR::Read (.smt.staging.repositories);
        list <string> staging_groups = (list <string>) SCR::Read (.smt.staging.groups);
	boolean repository_uptodate = nil;

	// Remember the selected value
	string current_value = nil;
        if (UI::WidgetExists (`catalogs))
            current_value = (string) UI::QueryWidget (`id (`catalogs), `Value);

        list <term> items = [];
        foreach (string catalogid, map one_catalog, catalogs, {

            foreach (string groupname, staging_groups, {
                y2milestone("Checking: %1-%2", catalogid, groupname);
                repository_uptodate = (boolean) SCR::Read(.smt.staging.repository.uptodate, $["repositoryid":catalogid,
                                                                                              "type":"testing",
                                                                                              "group":groupname]) &&
                    (boolean) SCR::Read(.smt.staging.repository.uptodate, $["repositoryid":catalogid,
                                                                            "type":"production",
                                                                            "group":groupname]);

                items = add(items, `item (`id (catalogid + "-" + groupname),
                           `icon(repository_uptodate ? smt_status_icons["repo-up-to-date"]:"":smt_status_icons["repo-not-up-to-date"]:""),
                           (one_catalog["TARGET"]:"" != "" ?
                           // Catalog Name (Target)
                           sformat (_("%1 (%2)(%3)"), one_catalog["NAME"]:"", one_catalog["TARGET"]:"", groupname)
                           :
                           sformat (_("%1 (%2)"), one_catalog["NAME"]:"", groupname)
                           ),
                           ((catalogid + "-" + groupname) == current_value)
                ));
            });
	});

	items = sort (term x, term y, items, {
	    return toupper(x[2]:"") < toupper (y[2]:"");
	});

	if (items == nil) items = [];

	items = sort (term a, term b, items, ``(a[2]:"" < b[2]:""));

	UI::ReplaceWidget (
	    `id (`catalogs_rp),
	    `Left (`ComboBox (`id (`catalogs), `opt(`notify), _("Repository &Name"), items))
	);

	if (size (items) > 0) {
	    UI::ChangeWidget (`id (`create_snapshot), `Enabled, true);
	    UI::ChangeWidget (`id (`category_filter), `Enabled, true);
	    UI::ChangeWidget (`id (`catalogs), `Enabled, true);
	} else {
	    UI::ChangeWidget (`id (`create_snapshot), `Enabled, false);
	    UI::ChangeWidget (`id (`category_filter), `Enabled, false);
	    UI::ChangeWidget (`id (`catalogs), `Enabled, false);
	}
    }

    void InitStagingTableDialog (string id) {
	RedrawRepositoriesStagingMenu();
	RedrawPatchesTable ("");
    }

    void AdjustAdditionalFilters () {
	// a mlti-selection-box label
	string msb_label = _("Exclude All Patches of Selected Categories");

	UI::OpenDialog (`VBox (
	    `MinWidth (size (msb_label), `MarginBox (
		1,1, `VBox (
		    `MultiSelectionBox (
			`id (`category_filters),
			msb_label,
			[]
		    )
		)
	    )),
	    `ButtonBox (
		`PushButton (`id (`ok), `opt (`okButton), Label::OKButton()),
		`PushButton (`id (`cancel), `opt (`cancelButton), Label::CancelButton())
	    )
	));

	list <term> items = maplist (string patch_type, string type_translated, patch_categories, {
	    map query = $[
		"type" : patch_type,
		"repositoryid" : selected_catalog,
                "group" : selected_staging_group,
	    ];
	    return `item (
		`id (patch_type), type_translated,
		(SCR::Read (.smt.staging.category_filter, query) == true)
	    );
	});

	if (items != nil) {
	    UI::ChangeWidget (`id (`category_filters), `Items, items);
	}

	any ret = UI::UserInput();
	if (ret == `ok) {
	    list <string> newly_active_filters =
		(list <string>) UI::QueryWidget (`id (`category_filters), `SelectedItems);

	    foreach (string patch_type, string type_translated, patch_categories, {
		map command = $[
		    "type" : patch_type,
		    "repositoryid" : selected_catalog,
                    "group" : selected_staging_group,
		    "status" : contains (newly_active_filters, patch_type),
		];

		SCR::Write (.smt.staging.category_filter, command);
	    });
	}

	UI::CloseDialog();
    }

    boolean SetPatchStatus (string patchid, boolean new_status) {
	return SCR::Write (
	    .smt.staging.patch.status,
	    $["repositoryid" : selected_catalog, "group" : selected_staging_group,
              "patchid" : patchid, "status" : new_status]
	);
    }

    void ReportFilteringNotAllowed () {
	// a pop-up message
	Report::Message (_("This repository does not allow patch filtering.
You can create snapshots of its current stage though."));
    }

    void TogglePatchStatus () {
	if (filtering_allowed_for_repository != true) {
	    ReportFilteringNotAllowed();
	    return;
	}

	string sel_patchid = (string) UI::QueryWidget (`id (`patches_table), `CurrentItem);

	if (IsPatchFilteredByType (sel_patchid)) {
	    // a pop-up message
	    Report::Message (_("This patch is filtered-out by a category-based filter
and thus its status cannot be changed in this dialog."));
	    return;
	}

	boolean status = current_patches[sel_patchid,"filtered"]:false;

	// Fallback
	if (status == nil) status = false;

	// Inverting the status: "filtered" used as new "status"
	if (SetPatchStatus (sel_patchid, status) != true) {
	    Report::Error (_("Unable to change the current patch status."));
	}

	boolean current_status = (boolean) SCR::Read (
	    .smt.staging.patch.status,
	    $["repositoryid" : selected_catalog, "group" : selected_staging_group, "patchid" : sel_patchid]
	);

	// update the cache
	current_patches[sel_patchid,"filtered"] = (current_status == false);
	string status_icon = GetPatchStatusIcon (current_patches[sel_patchid]:$[]);
	UI::ChangeWidget (`id(`patches_table), `Item (sel_patchid, 3), (text_mode ? status_icon : `icon (smt_patch_icons[status_icon]:"")));
	// focus the table again
	UI::SetFocus (`id (`patches_table));
    }

    void ChangeAllListedPatches (boolean new_state) {
	if (filtering_allowed_for_repository != true) {
	    ReportFilteringNotAllowed();
	    return;
	}

	foreach (string patchid, map patchdetails, current_patches, {
	    // Patch cannot be changed
	    if (IsPatchFilteredByType (patchid))
		return;

	    // Patch has already the requierd status
	    if (current_patches[patchid,"filtered"]:false != new_state)
		return;

	    SetPatchStatus (patchid, new_state);
	});
    }

    string signing_passphrase = nil;

    boolean AskForSnapshotSigningKey (map <string, string> & snapshot_settings) {
	map <string, string> backup_settings = snapshot_settings;

	// uses 'repositoryid' key
	boolean can_be_filtered = (boolean) SCR::Read (.smt.repository.staging_allowed, snapshot_settings);

	// Repository cannot be filtered, thus cannot be modified
	// thus doesn't need to be re/signed
	if (can_be_filtered != true) {
	    y2milestone ("Repository cannot be filtered, re/signing not required");
	    return true;
	}

	// Read the key ID only if defined
	string key_id = (SMTData::GetCredentialsDefined ("LOCAL", "signingKeyID") == true
	    ? SMTData::GetCredentials ("LOCAL", "signingKeyID") : nil);

	// No re/signing key in use, ignoring
	if (key_id == nil || key_id == "") {
	    y2milestone ("No signing key used");
	    return true;
	}

	y2milestone ("Using KeyID: %1", key_id);
	snapshot_settings["key"] = key_id;

	// Read the signingKeyPassphrase only if defined
	string tmp_passphrase = (SMTData::GetCredentialsDefined ("LOCAL", "signingKeyPassphrase") == true
	    ? SMTData::GetCredentials ("LOCAL", "signingKeyPassphrase") : nil);

	// Passphrase defined in config file
	if (tmp_passphrase != nil) {
	    y2milestone ("Using KeyPassphrase from config file");
	    snapshot_settings["passphrase"] = tmp_passphrase;
	    return true;
	// Passphrase already entered
	} else if (signing_passphrase != nil) {
	    y2milestone ("Using cached KeyPassphrase");
	    snapshot_settings["passphrase"] = signing_passphrase;
	    return true;
	}

	// 0xABDEF -> ABDEF
	string key_id_match = key_id;
	if (regexpmatch (key_id_match, "^0x.*"))
	    key_id_match = regexpsub (key_id_match, "^0x(.*)", "\\1");

	list <map> keys = filter (map one_key, GPG::PrivateKeys(), {
	    return (one_key["id"]:nil == key_id_match || one_key["id"]:nil == "0x"+key_id_match);
	});

	// Key description
	string key_description = sformat ("Key ID: %1", key_id);

	if (size (keys) > 0) {
	    // Multiline key description
	    key_description = sformat (_("Key ID: %1
UID: %2
Fingerprint: %3"), key_id, mergestring (keys[0,"uid"]:[],"\n"), keys[0,"fingerprint"]:"");
	}

	UI::OpenDialog (
	    `VBox (
		// pop-up heading
		`Left (`Heading (_("Signing Key Passphrase"))),
		// pop-up dialog message
		// %1 is replaced with a (possibly multiline) key descrioption
		`Left (`Label (sformat(_("SMT is configured to sign the snapshot with the following key:

%1

Enter the key passphrase and press OK,
otherwise press Cancel to skip the signing procedure."), key_description))),
		`VSpacing (1),
		`HSquash (`MinWidth (25, `VBox (
		    `Password (`id (`pass1), `opt(`hstretch), _("Key &Passphrase")),
		    `Password (`id (`pass2), `opt(`hstretch), _("&Once Again"))
		))),
		`ButtonBox (
		    `PushButton (`id (`ok), `opt (`okButton, `default), Label::OKButton()),
		    `PushButton (`id (`cancel), `opt (`cancelButton), Label::CancelButton())
		)
	    )
	);

	UI::SetFocus (`id (`pass1));
	any ret = nil;

	while (true) {
	    ret = UI::UserInput();

	    if (ret == `cancel) {
		y2warning ("Signing will be disabled");
		snapshot_settings = backup_settings;
		break;
	    } else if (ret == `ok) {
		string p1 = (string) UI::QueryWidget (`id (`pass1), `Value);
		string p2 = (string) UI::QueryWidget (`id (`pass2), `Value);

		if (p1 != p2) {
		    // pop-up error message
		    Report::Error (_("Entered passphrases are not identical."));
		    UI::SetFocus (`id (`pass1));
		    continue;
		}

		y2milestone ("Passphrase has been entered");
		snapshot_settings["passphrase"] = p1;
		break;
	    }
	}

	UI::CloseDialog();

	return true;
    }

    boolean CreateSnapshot (string type) {
	map <string, string> snapshot_settings = $["repositoryid":selected_catalog,
                                                   "group" : selected_staging_group,
                                                   "type":type];
	// Do not log any passwords!
	y2milestone ("Creating snapshot: %1", snapshot_settings);

	// We allow to change the content just for the 'testing'
	// snapshot, 'production' is just a copy of that
	if (type == "testing" && AskForSnapshotSigningKey (snapshot_settings) != true)
	    return false;

	// a bussy message
	UI::OpenDialog (`Label(_("Creating repository snapshot...")));

	y2milestone ("Writing patches...");
	// Flush the cache (filters) from memory to database
	SCR::Write (.smt.staging.patches, nil);

	y2milestone ("Writing snapshot...");
	// Create snapshot
	boolean ret = (boolean) SCR::Write (.smt.staging.snapshot, snapshot_settings);
	y2milestone ("Creating snapshot finished with result: %1", ret);

	UI::CloseDialog();

	if (ret != true)
	    // a pop-up error message
	    Report::Error (_("An error has occurred while creating the snapshot."));

	RedrawRepositoriesStagingMenu();
	UpdateRepoDetails();

	return ret;
    }

    symbol HandleClientsTableDialog (string id, map event) {
	any action = event["ID"]:nil;

	if (action == `clients_table)
	    RedrawClientsTableDetails();

	return nil;
    }

    symbol HandleStagingTableDialog (string id, map event) {
	any action = event["ID"]:nil;
	any reason = event["EventReason"]:nil;

	// Selected another patch in table or double-click
	if (action == `patches_table) {
	    // Double-click on patch in table
	    if (reason == "Activated") {
		TogglePatchStatus();
	    // The rest...
	    } else {
		RedrawPatchesDetails();
	    }
	} else if (action == `toggle_patch_status) {
	    TogglePatchStatus();
	// Selected another catalog
	} else if (action == `catalogs) {
	    // Reset the category filter when selecting another catalog
	    ResetPatchCategoryFilter();
	    RedrawPatchesTable ("");
	} else if (action == `additional_filters) {
	    AdjustAdditionalFilters();
	    RedrawPatchesTable (GetSelectedPatchFilter());
	} else if (action == `category_filter) {
	    RedrawPatchesTable (GetSelectedPatchFilter());
	} else if (action == `all_listed_enable) {
	    ChangeAllListedPatches (true);
	    RedrawPatchesTable (GetSelectedPatchFilter());
	} else if (action == `all_listed_disable) {
	    ChangeAllListedPatches (false);
	    RedrawPatchesTable (GetSelectedPatchFilter());
	} else if (action == `create_snapshot_testing) {
	    CreateSnapshot ("testing");
	    RedrawPatchesTable (GetSelectedPatchFilter());
	} else if (action == `create_snapshot_production) {
	    CreateSnapshot ("production");
	    RedrawPatchesTable (GetSelectedPatchFilter());
	}

	return nil;
    }

//    void StoreStagingTableDialog (string id, map event) {
//    }

    boolean EmailValid (string e_mail) {
	// very simple e-mail validator
	return (regexpmatch (e_mail, ".+@.+\\..+"));
    }

    void HandleAddEditEmailAddress (string e_mail) {
	if (e_mail == nil) e_mail = "";

	UI::OpenDialog (
	    `VBox (
		`HSquash (`MinWidth (40, `InputField (`id ("e-mail"), (e_mail == "" ?
		    _("New &E-Mail")
		    :
		    _("Editing &E-Mail")
		), e_mail))),
		`HBox (
		    `PushButton (`id (`ok), `opt (`default, `key_F10), Label::OKButton()),
		    `HSpacing  (2),
		    `PushButton (`id (`cancel), `opt (`key_F9), Label::CancelButton())
		)
	    )
	);

	UI::SetFocus (`id ("e-mail"));

	any ret = nil;
	while (true) {
	    ret = UI::UserInput();

	    // Cancel pressed
	    if (ret != `ok)
		break;

	    // OK pressed
	    string new_mail = (string) UI::QueryWidget (`id ("e-mail"), `Value);

	    if (EmailValid (new_mail)) {
		report_e_mails = filter (string one_email, report_e_mails, { return one_email != e_mail; });
		report_e_mails = toset (add (report_e_mails, new_mail));
		break;
	    } else {
		Report::Error (sformat (_("E-mail '%1' is not valid."), new_mail));
		UI::SetFocus (`id ("e-mail"));
	    }
	}

	UI::CloseDialog();

	if (ret == `ok)
	    RedrawReportEmailsTable();
    }

    symbol HandleReportEmailTableDialog (string id, map event) {
	if (id != "reporting")
	    return nil;

	any event_id = event["ID"]:nil;

	if (event_id == `add) {
	    HandleAddEditEmailAddress ("");
	} else if (event_id == `edit) {
	    string currently_selected = (string) UI::QueryWidget (`id (`report_table), `CurrentItem);
	    HandleAddEditEmailAddress (currently_selected);
	} else if (event_id == `delete) {
	    string currently_selected = (string) UI::QueryWidget (`id (`report_table), `CurrentItem);
	    if (Confirm::Delete (currently_selected)) {
		report_e_mails = filter (string one_email, report_e_mails, { return one_email != currently_selected; });
		RedrawReportEmailsTable();
	    }
	}

	return nil;
    }

    boolean ToggleRepository (string current_id, string entry) {
	if (current_id == nil) {
	    y2error ("Erroneous ID: %1", current_id);
	    // pop-up error message
	    Report::Error (_("Internal Error: Cannot toggle the current state."));
	    return nil;
	}

	boolean current_state = (boolean) catalogs_info[current_id, entry]:nil;

	if (current_state == nil) {
	    y2error ("Erroneous entry: %1 (%2)", catalogs_info[current_id]:$[], entry);
	    // pop-up error message
	    Report::Error (_("Internal Error: Cannot toggle the current state."));
	    return nil;
	}

	map <string, any> cmd_params = $["repositoryid":current_id];
	integer col_to_change = 0;
	boolean new_state = (current_state == false);

	if (entry == "mirroring") {
	    cmd_params["mirroring"] = new_state;
	    col_to_change = 2;
	} else if (entry == "staging") {
	    cmd_params["staging"] = new_state;
	    col_to_change = 3;
	} else {
	    y2error ("Unknown entry to change: %1", entry);
	    // pop-up error message
	    Report::Error (_("Internal Error: Cannot toggle the current state."));
	    return nil;
	}

	boolean success = (boolean) SCR::Write (.smt.repository.set, cmd_params);
	y2milestone ("Adjusting repository %1: %2", cmd_params, success);

	if (success != true) {
	    Report::Error (_("Internal Error: Cannot toggle the current state."));
	} else {
	    // Switch the current state
	    current_state = (current_state == false);
	    catalogs_info[current_id, entry] = current_state;
	    UI::ChangeWidget (`id(`catalogs_table), `Item (current_id, col_to_change), (current_state == true ? yes:no));
	}

	AdjustRepositoriesButtons();
    }

    void MirrorRepository (string repository_id) {
	if (repository_id == nil || repository_id == "") {
	    y2error ("Unable to mirror: %1", repository_id);
	}

	y2milestone ("Mirroring repository: %1", repository_id);

	string cmd = sformat (
	    "/usr/sbin/smt-mirror -L '%1' --repository '%2'",
	    String::Quote (default_mirrroring_log),
	    String::Quote (repository_id)
	);

	y2milestone ("Starting process: %1", cmd);
	integer process_PID = (integer) SCR::Execute (.process.start_shell, cmd);
	y2milestone ("Got PID: %1", process_PID);

	if (process_PID == nil) {
	    // Error message
	    Report::Error (_("Unable to mirror the selected repository."));
	    return;
	}

	UI::OpenDialog (`VBox (
	    `Left (`Heading (_("Mirroring Repository"))),
	    `MinWidth (80, `LogView (`id (`log), _("&Progress"), 16, 1024)),
	    `ReplacePoint (`id (`button), `PushButton (`id (`cancel), _("&Stop")))
	));

	UI::ChangeWidget (`id (`log), `LastLine,
	    sformat(_("Started mirroring the selected repository with process ID: %1\n"), process_PID)
	);

	string line = "";
	any ret = nil;
	boolean aborted = false;

	while ((boolean) SCR::Read (.process.running, process_PID) == true) {
	    line = (string) SCR::Read (.process.read_line, process_PID);

	    if (line != nil) {
		UI::ChangeWidget (`id (`log), `LastLine, line + "\n");
	    } else {
		sleep (200);
	    }

	    ret = UI::PollInput();

	    if (ret == `cancel) {
		y2milestone ("Really abort?");
		if (Popup::AnyQuestion (
		    // a headline
		    _("Aborting the Mirroring"),
		    // a pop-up question
		    _("Are you sure you want to abort the current mirroring process?"),
		    // push button
		    _("Abort Mirroring"),
		    // push button
		    _("Continue Mirroring"),
		    `focus_no
		)) {
		    UI::ChangeWidget (`id (`log), `LastLine, _("Aborting...\n"));
		    y2milestone ("Aborting...");
		    SCR::Execute (.process.kill, process_PID);
		    aborted = true;
		    break;
		}
	    }
	}

	// any lines left in buffer?
	line = (string) SCR::Read (.process.read, process_PID);
	if (line != nil && size (line) > 0)
	    UI::ChangeWidget (`id (`log), `LastLine, line + "\n");

	SCR::Execute (.process.release, process_PID);

	if (! aborted) {
	    // Flush the internal cache after mirroring
	    y2milestone (
		"Staging allowed: %1: %2",
		repository_id,
		SCR::Read (.smt.repository.staging_allowed, $["repositoryid":repository_id, "force_check":true])
	    );

	    // BNC #519216: Purge cache right after mirroring
	    SCR::Execute (.smt.repository.purge_cache, $["repositoryid":repository_id, "group":selected_staging_group]);

	    UI::ChangeWidget (`id (`log), `LastLine, _("Finished\n"));
	    UI::ReplaceWidget (`id (`button), `PushButton (`id (`ok), Label::OKButton()));
	    UI::UserInput();
	}

	UI::CloseDialog();
    }

    list <string> filters = [];

    symbol HandleRepositoriesTableDialog (string id, map event) {
	if (id != "repositories")
	    return nil;

	any event_id = event["ID"]:nil;

	string current_id = (string) UI::QueryWidget (`id (`catalogs_table), `CurrentItem);

	if (event_id == `toggle_mirroring) {
	    ToggleRepository (current_id, "mirroring");
	} else if (event_id == `toggle_staging) {
	    ToggleRepository (current_id, "staging");
	} else if (event_id == `mirror_now) {
	    MirrorRepository (current_id);
	    RedrawCatalogsTable (filters);
	} else if (event_id == `catalogs_table) {
	    // Table->double_click
	    if (event["EventReason"]:"" == "Activated") {
		ToggleRepository (current_id, "mirroring");
	    // Table->selected(_other_item)
	    } else {
		AdjustRepositoriesButtons();
	    }
	} else if (is (event_id, string) && regexpmatch (tostring (event_id), "^catalogs_filter_")) {
	    integer filter_id = tointeger (regexpsub (tostring (event_id), "^catalogs_filter_(.*)", "\\1"));

	    if (filter_id == nil) {
		y2error ("Unable to get filter ID from %1", filter_id);
		return nil;
	    }

	    filters = [];
	    integer current_fid = -1;
	    string filter_item = nil;

	    while (current_fid < filter_id) {
		current_fid = current_fid + 1;
		filter_item = (string) UI::QueryWidget (`id (sformat ("catalogs_filter_%1", current_fid)), `Value);
		if (filter_item == nil)
		    break;
		filters = add (filters, filter_item);
	    }

	    if (filters == nil) filters = [];
	    RedrawCatalogsTable (filters);
	}

	// Catalog have been toggled, re-focus the table again
	UI::SetFocus (`id (`catalogs_table));
	return nil;
    }

    map <string, string> nrdays_to_names = $[
	"0" : _("Sunday"),
	"1" : _("Monday"),
	"2" : _("Tuesday"),
	"3" : _("Wednesday"),
	"4" : _("Thursday"),
	"5" : _("Friday"),
	"6" : _("Saturday"),
    ];

    string CutZeros (string with_zeros) {
	if (regexpmatch (with_zeros, "^0.+")) {
	    with_zeros = regexpsub (with_zeros, "^0(.+)", "\\1");
	}

	return with_zeros;
    }

    map CutPerriodicalSigns (map settings) {
	map tmp_settings = settings;

	foreach (string key, ["hour", "minute", "day_of_month", "day_of_month"], {
	    if (regexpmatch (settings[key]:"", "\\*/")) {
		settings[key] = regexpsub (settings[key]:"", "\\*/(.*)", "\\1");
	    }
	});

	if (tmp_settings != settings) {
	    y2milestone ("Periodicall settings changed %1 -> %2", tmp_settings, settings);
	}

	return settings;
    }

    string FindJobName (string command) {
	string ret = nil;

	foreach (string script_command, string script_name, smt_cron_scripts, {
	    if (regexpmatch (command, script_command)) {
		ret = script_name;
		break;
	    }
	});

	// BNC #520557: Manual or additional cron commands
	if (ret == nil) {
	    y2error ("Unknown cron command: %1", command);
	    ret = sformat (_("Command: %1"), command);
	}

	return ret;
    }

    string FindJobScript (string command) {
	string ret = "";

	foreach (string script_command, string script_name, smt_cron_scripts, {
	    if (regexpmatch (command, script_command)) {
		ret = script_command;
		break;
	    }
	});

	return ret;
    }

    boolean smt_support_checked = nil;

    /**
     * Redraws the table of currently scheduled NU mirrorings.
     */
    void RedrawScheduledMirroringTable () {
	// Offer adding the script only if exists
	if (smt_support_checked != true) {
	    smt_support_checked = true;

	    if (FileUtils::Exists("/usr/sbin/smt-support")) {
		y2milestone ("SMT support script exists");
		smt_cron_scripts["/usr/sbin/smt-support -U"] = _("Uploading Support Configs");
	    } else {
		y2milestone ("SMT support script does not exist");
	    }
	}

	list <term> items = [];

	integer counter = -1;
	foreach (map one_entry, SMTData::GetCronSettings(), {
	    counter = counter + 1;

	    if (one_entry == nil || one_entry == $[])
		return;

	    foreach (string key, ["day_of_month", "day_of_week", "hour", "minute", "month"], {
		if (one_entry[key]:nil == nil)
		    one_entry[key] = "*";
	    });

	    term item = `item (`id (counter));

	    item = add (item, FindJobName (one_entry["command"]:""));

	    // covers */15 - every 15 minutes/hours
	    boolean periodically = false;

	    // More often than 'daily'
	    if (regexpmatch (one_entry["hour"]:"", "\\*/") || regexpmatch (one_entry["minute"]:"", "\\*/")) {
		periodically = true;
		// Script-call period, used as a table item
		item = add (item, _("Periodically"));
		item = add (item, "--");
		item = add (item, "--");
	    // Monthly
	    } else if (one_entry["day_of_month"]:"*" != "*") {
		// Script-call period, used as a table item
		item = add (item, _("Monthly"));
		item = add (item, "--");
		item = add (item, one_entry["day_of_month"]:_("Undefined"));
	    // Weekly
	    } else if (one_entry["day_of_week"]:"*" != "*") {
	    // Script-call period, used as a table item
		item = add (item, _("Weekly"));
		item = add (item, nrdays_to_names[one_entry["day_of_week"]:""]:_("Undefined"));
		item = add (item, "--");
	    // Daily
	    } else {
		// Script-call period, used as a table item
		item = add (item, _("Daily"));
		item = add (item, "--");
		item = add (item, "--");
	    }

	    one_entry = CutPerriodicalSigns (one_entry);

	    if (periodically && one_entry["hour"]:"*" != "*" && one_entry["hour"]:"0" != "0") {
		item = add (item, sformat (_("Every %1 hours"), one_entry["hour"]:_("Undefined")));
	    } else if (periodically) {
		item = add (item, "--");
	    } else {
		item = add (item, one_entry["hour"]:_("Undefined"));
	    }

	    if (periodically && one_entry["minute"]:"*" != "*" && one_entry["minute"]:"0" != "0") {
		item = add (item, sformat (_("Every %1 minutes"), one_entry["minute"]:_("Undefined")));
	    } else if (periodically) {
		item = add (item, "--");
	    } else {
		item = add (item, one_entry["minute"]:_("Undefined"));
	    }

	    items = add (items, item);
	});

	if (items == nil) {
	    items = [];
	    y2error ("Erroneous items!");
	}
	UI::ChangeWidget (`id ("scheduled_NU_mirroring"), `Items, items);

	boolean buttons_enabled = (items != nil && size (items) != 0);
	UI::ChangeWidget (`id (`edit), `Enabled, buttons_enabled);
	UI::ChangeWidget (`id (`delete), `Enabled, buttons_enabled);
    }

    void DisableScheduledMirroringTable () {
	UI::ChangeWidget (`id ("scheduled_NU_mirroring"), `Enabled, false);
	UI::ChangeWidget (`id (`add), `Enabled, false);
	UI::ChangeWidget (`id (`edit), `Enabled, false);
	UI::ChangeWidget (`id (`delete), `Enabled, false);
    }

    boolean cron_rpms_checked = false;
    boolean cron_rpms_installed = nil;

    void InitScheduledDownloadsDialog (string id) {
	// Lazy check for cron but only once
	if (cron_rpms_checked != true) {
	    cron_rpms_checked = true;
	    cron_rpms_installed = PackageSystem::CheckAndInstallPackagesInteractive (["cron"]);
	    y2milestone ("cron RPM is installed: %1", cron_rpms_installed);
	}

	if (cron_rpms_installed != true) {
	    DisableScheduledMirroringTable();
	    // TRANSLATORS: informational message (Report::Message)
	    Report::Message (_("Scheduled jobs have been disabled due to missing packages.
To install the missing packages and set up the scheduled jobs,
you need to restart the YaST SMT Configuration module."));
	    return;
	}

	RedrawScheduledMirroringTable();
    }

    void AdjustAddEditDialogToFrequency () {
	symbol current_freq = (symbol) UI::QueryWidget (`id (`frequency), `Value);

	boolean day_of_week_available  = false;
	boolean day_of_month_available = false;

	if (current_freq == `weekly) {
	    day_of_week_available = true;
	} else if (current_freq == `monthly) {
	    day_of_month_available = true;
	}

	if (current_freq == `periodically) {
	    UI::ChangeWidget (`id ("hour"), `Label, _("Every H-th &Hour"));
	    UI::ChangeWidget (`id ("minute"), `Label, _("Every M-th &Minute"));
	} else {
	    UI::ChangeWidget (`id ("hour"), `Label, _("&Hour"));
	    UI::ChangeWidget (`id ("minute"), `Label, _("&Minute"));
	}

	UI::ChangeWidget (`id ("day_of_week"),  `Enabled, day_of_week_available);
	UI::ChangeWidget (`id ("day_of_month"), `Enabled, day_of_month_available);
    }

    /**
     * Validates and saves the cron entry.
     */
    boolean ValidateAndSaveScheduledMirroring (integer schd_id) {
	map settings = $[
	    "day_of_month"	: "*",
	    "day_of_week"	: "*",
	    "hour"		: "*",
	    "minute"		: "*",
	    "month"		: "*",
	    "command"		: "",
	];

	symbol current_freq = (symbol) UI::QueryWidget (`id (`frequency), `Value);

	string hour = tostring (UI::QueryWidget (`id ("hour"), `Value));
	string minute = tostring (UI::QueryWidget (`id ("minute"), `Value));
	string day_of_month = tostring (UI::QueryWidget (`id ("day_of_month"), `Value));
	string day_of_week = tostring (UI::QueryWidget (`id ("day_of_week"), `Value));

	settings["hour"] = CutZeros (hour);
	settings["minute"] = CutZeros (minute);

	// Periodical frequency needs to add "*/X" periodical sign
	if (current_freq == `periodically) {
	    if (settings["hour"]:"0" != "0" && settings["hour"]:"*" != "*") {
		settings["hour"] = sformat ("*/%1", settings["hour"]:"0");
	    } else {
		settings["hour"] = "*";
	    }
	    if (settings["minute"]:"0" != "0" && settings["minute"]:"*" != "*") {
		settings["minute"] = sformat ("*/%1", settings["minute"]:"0");
	    } else {
		settings["minute"] = "*";
	    }
	} else if (current_freq == `weekly) {
	    settings["day_of_week"] = day_of_week;
	} else if (current_freq == `monthly) {
	    settings["day_of_month"] = day_of_month;
	}

	string command = (string) UI::QueryWidget (`id (`job_to_run), `Value);
	settings["command"] = command;

	if (schd_id != nil && schd_id > -1) {
	    SMTData::ReplaceCronJob (schd_id, settings);
	} else {
	    SMTData::AddNewCronJob (settings);
	}

	return true;
    }

    /**
     * Opens up dialog for adding or editing a cron-job entry.
     *
     * @param integer schd_id offset ID in the list of current jobs
     *        -1 for adding a new entry
     */
    boolean AddEditScheduledMirroring (integer schd_id) {
	map settings = $[];
	boolean editing = false;
	boolean dialog_ret = false;

	if (schd_id != nil && schd_id > -1) {
	    settings = SMTData::GetCronSettings()[schd_id]:$[];
	    if (settings == nil) {
		y2error ("Wrong settings on offset %1: %2", schd_id, SMTData::GetCronSettings());
	    }
	    editing = true;
	}

	list <term> day_of_week = maplist (string dof_id, string dof_name, nrdays_to_names, {
	    return `item (`id (dof_id), dof_name, (settings["day_of_week"]:nil == dof_id));
	});

	symbol freqency_sel = `daily;

	// "*/15" - Every 15 minutes, hours
	if (regexpmatch (settings["hour"]:"", "\\*/") || regexpmatch (settings["minute"]:"", "\\*/")) {
	    freqency_sel = `periodically;
	    settings = CutPerriodicalSigns (settings);
	// Monthly
	} else if (settings["day_of_month"]:"*" != "*") {
	    freqency_sel = `monthly;
	// Weekly
	} else if (settings["day_of_week"]:"*" != "*") {
	    freqency_sel = `weekly;
	}

	if (settings["hour"]:nil == "*")
	    settings["hour"] = "0";

	if (settings["minute"]:nil == "*")
	    settings["minute"] = "0";

	if (settings["day_of_month"]:nil == "*")
	    settings["day_of_month"] = "0";

	integer hour		= tointeger (CutZeros (settings["hour"]:"0"));
	integer minute		= tointeger (CutZeros (settings["minute"]:"0"));
	integer day_of_month	= tointeger (CutZeros (settings["day_of_month"]:"0"));

	list <term> scripts = maplist (string script_command, string script_name, smt_cron_scripts, {
	    return `item (`id (script_command), script_name);
	});

	scripts = sort (term x, term y, scripts, ``(x[1]:"A" < y[1]:"A"));

	UI::OpenDialog (
	    `VBox (
		`HSpacing (35),
		`Left (`Heading ((editing ? _("Editing a SMT Scheduled Job"):_("Adding New SMT Scheduled Job")))),
		`VSpacing (1),
		`HBox (
		    `Left(`ComboBox (
			`id (`frequency),
			`opt (`notify),
			_("&Frequency"),
			[
			    `item (`id (`daily), _("Daily"), (freqency_sel == `daily)),
			    `item (`id (`weekly), _("Weekly"), (freqency_sel == `weekly)),
			    `item (`id (`monthly), _("Monthly"), (freqency_sel == `monthly)),
			    `item (`id (`periodically), _("Periodically"), (freqency_sel == `periodically))
			]
		    )),
		    `HSpacing (2),
		    `Left (`ComboBox (
			`id (`job_to_run),
			_("&Job to Run"),
			scripts
		    ))
		),
		`VSpacing (1),
		`Frame (
		    _("Job Start Time"),
		    `HBox (
			`HSpacing (2),
			`VBox (
			    `ComboBox (`id ("day_of_week"), `opt(`hstretch), _("Day of the &Week"), day_of_week),
			    `IntField (`id ("hour"), _("&Hour"), 0, 24, hour)
			),
			`HSpacing (2),
			`VBox (
			    `IntField (`id ("day_of_month"), _("&Day of the Month"), 1, 31, day_of_month),
			    `IntField (`id ("minute"), _("&Minute"), 0, 59, minute)
			),
			`HSpacing (2)
		    )
		),
		`VSpacing (1),
		`HBox (
		    `PushButton (`id (`ok), `opt (`default, `key_F10), (editing ? Label::OKButton():Label::AddButton())),
		    `HSpacing (2),
		    `PushButton (`id (`cancel), `opt (`key_F9), Label::CancelButton())
		)
	    )
	);

	AdjustAddEditDialogToFrequency();

	// select the right script if editing already entered cron job
	if (editing) {
	    string script = FindJobScript (settings["command"]:"");

	    // BNC #520557: Handling unknown script
	    if (script == "" || script == nil) {
		y2error ("Unable to determine script name %1", settings);

		scripts = add (
		    scripts,
		    `item (`id (settings["command"]:""), sformat (_("Command: %1"), settings["command"]:""))
		);
		UI::ChangeWidget (`id (`job_to_run), `Items, scripts);

		script = settings["command"]:"";
	    }

	    UI::ChangeWidget (`id (`job_to_run), `Value, script);
	}

	any ret = nil;

	while (true) {
	    ret = UI::UserInput();

	    if (ret == `frequency) {
		AdjustAddEditDialogToFrequency();
	    } else if (ret == `ok || ret == `next) {
		if (! ValidateAndSaveScheduledMirroring (schd_id)) {
		    continue;
		} else {
		    dialog_ret = true;
		    break;
		}
	    } else if (ret == `cancel) {
		dialog_ret = false;
		break;
	    } else {
		y2error ("Unhandled ret: %1", ret);
	    }
	}

	UI::CloseDialog();

	return dialog_ret;
    }

    void SetFocusTable () {
	UI::SetFocus (`id ("scheduled_NU_mirroring"));
    }

    symbol HandleScheduledDownloadsDialog (string id, map event) {
	any action = event["ID"]:nil;

	boolean changed = false;

	// Add
	if (action == `add) {
	    changed = AddEditScheduledMirroring (-1);
	    SetFocusTable();

	// Edit
	} else if (action == `edit) {
	    integer current_item = (integer) UI::QueryWidget (`id ("scheduled_NU_mirroring"), `CurrentItem);
	    changed = AddEditScheduledMirroring (current_item);
	    SetFocusTable();

	// Delete
	} else if (action == `delete) {
	    integer current_item = (integer) UI::QueryWidget (`id ("scheduled_NU_mirroring"), `CurrentItem);

	    if (! Confirm::DeleteSelected()) {
		SetFocusTable();
		return nil;
	    }

	    SMTData::RemoveCronJob (current_item);
	    changed = true;
	    SetFocusTable();
	}

	if (changed) {
	    RedrawScheduledMirroringTable();
	}

	return nil;
    }

    void StoreScheduledDownloadsDialog (string id, map event) {
	return nil;
    }

    boolean ReallyExit () {
	// TRANSLATORS: yes-no popup
	return Popup::YesNo (_("Really exit?
All changes will be lost."));
    }
}
